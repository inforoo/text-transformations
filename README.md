Методы обработки текста
---------------
Задача поиска и замены является одной из базовых, при работе с текстовыми данными, которыми могут быть, как произвольный литературный текст, исходные код, представление данных, в частности, биологических. Для её решения могут использоваться различные инструменты, в зависимости от сложности задачи.

### Замена подстроки

Самая простая ситуация, когда одну подстроку `fixed_target_substring` 
надо заменить на другую `new_substring`:

    [text_before]fixed_target_substring[text_after] --> [text_before]new_substring[text_after]

Любой язык программирования предоставляет функцию замены. При этом бывают задачи поиска и замены первой и, в такой ситуации, обычно единственной найденной подстроки (это скорее относится к конкретному предложению), а бывают задачи поиска и замены всех таких подстрок, для чего может быть предусмотрена опция в соответствующей функции.

### Поиск по шаблону

Для поиска и замены подстрок, которые могут различаться друг от друга, но иметь определённую простую структуру используются "языки шаблонов", к примеру, как в командной строке. 

TODO: пример 

### Регулярные выражения

Для поиска и замены подстрок с более сложной структурой, используется "язык регулярных выражений". К примеру, структура может быть такой:

    [label]{[target_word]}, 

где `label` - это некоторое ключевое фиксированное слово, `{`,`}` - символы фигурных скобок, `target_word` - последовательность состоящая из букв определённого алфавита.

На языке регулярных выражений эта структура описывается как: 

TODO: пример

Этой структуре с `label=\begin` соответствуют следующие подстроки в тексте:

    \begin{hello}, \begin{world}, \begin{hello}}, \begin{abra\begin{cadabra}}

К предпоследней строке применение этого шаблона вернёт `hello`, вместо `hello}`.
К последней строке применение этого шаблона вернёт два результата: `abra\begin{cadabra}` и `cadabra`, если символы `\` и `{` допустимы в алфавите, и не вернёт результатов вообще, если не допустимы. Заметим, что если допустим и `}`, то в результате может вернуться строка, выходящая за соответствующую скобку, вплоть до конца текста. На этих примерах видны проблемы, возникающие при усложении структуры. 

В конечном итоге такие задачи сводятся к тем, что решаются методами синтаксического разбора, к примеру, в трансляторах языков программирования. Но когда нам не нужен синтаксический разбор такого уровня, приходится решать задачу другими средствами. 

### Поиск с учётом вложенности, comby

Следующая задача может быть решена в цикле, с контролем вложенности (то есть нужно найти пару соответствующих друг другу скобок). Нужно найти `fixed_target_substring` в тексте, но только там, где она содержится внутри блока начинающегося с `label`:

    [text_before_label]
    [label]{
        [text_before]
        `fixed_target_substring`
        [text_after]
        }
    [text_after_label]

TODO: почему не решить с помощью регулярных выражений, ни в жадном, ни в ленивым режиме? примеры ошибок, как в разделе про регулярные выражения.

Cуществует специальный инструмент `comby`
https://comby.dev/ и соответствующая библиотека https://pypi.org/project/comby/

TODO: решить задачу с помощью comby на python. Пример в файле `example.txt`

TODO: идея на будущее - есть языки типа XPath, Jsonpath которые как-раз могут производить поиск с учётом вложенности в xml и json форматах, соответственно. Идея в том, что текст можно сначала преобразовать в эти форматы, и уже потом для поиска можно будет пользоваться этими инструментами с большой функциональностью.    

Замечание о регулярных выражениях
---------------
Задачи включающие учёт вложенности не решаются с помощью языка регулярных выражений, так как с их помощью нельзя проверить правильность скобочной структуры.
